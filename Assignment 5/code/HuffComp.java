import java.io.*;
import java.util.*;

public class HuffComp
{
   private static File huff;                                                //file to be read
   private static Scanner fileReader;                                       //Scanner that reads the file
   private static ArrayList<Character> leaves = new ArrayList<Character>(); //holds characters for the table
   private static ArrayList<String> values =  new ArrayList<String>();      //holds the binary digits of the characters
     
   
   //main method
   public static void main(String[] args) throws IOException
   {
      Scanner keyboard = new Scanner(System.in); //reads user input
      BinaryNode<Character> tree = null;         //binary node tree
         
      System.out.println("Enter the file you would like to read from");
      huff = new File(keyboard.nextLine()); //sets the file to the one requested
      fileReader = new Scanner(huff);       //Creates the scanner from the file
      tree = readTree(tree);                //sets the tree to the one generated by the readTree method
      
      //printTree(tree); debugging code
      
      setValues(tree);                     //sends the tree to the setValues method
      
      outputTable();                       //calls the method to output the table
      String input;
      do //always runs once
      {
         System.out.println("If you would like to encode, enter 1. If you would like to decode, enter 2. " + 
                            "If you would like to quit, enter 3."); //ask user if they want to encode, decode, or quit
        
        
         input = keyboard.nextLine();
        
         if(input.equals("1"))  //checks if the user wants to encode or decode. If the input is 1, it encodes
         {
            System.out.println("Enter the message you would like to encode");  
            encode(keyboard.nextLine().toUpperCase().toCharArray());   //user inputs the message to encode, which is sent to the encode message as a char array
         }
         else if(input.equals("2")) //if the input is 2, it decodes
         {
            System.out.println("Enter the message you would like to decode");
            decode(tree, keyboard.nextLine()); //sends the tree and the message to decode to the decoding method
         }
         
      }while(!input.equals("3")); //If the input is 3, quits.
      
      fileReader.close();  //closes the file scanner
   }
     
     
     /*
         this is the method used for creating the binary tree used through the rest of the program. It reads from the file
         and determines how to branch out from the input
     */
   public static BinaryNode<Character> readTree(BinaryNode<Character> huffTree)
   {
      if(fileReader.hasNext()) //makes sure there are lines to read
      {
         String line = fileReader.nextLine(); //reads next line from file
         if (line.equals("I"))  //if the input is "I"
         {
            if(huffTree == null)  //checks if the tree is null. Only matters if huffTree is the root node in the initial call to the method
            {
               huffTree = new BinaryNode<Character>();  //creates the root node
            }
               
            huffTree.setLeftChild(readTree(new BinaryNode<Character>())); //recursive call to the left
            huffTree.setRightChild(readTree(new BinaryNode<Character>())); //recursive call to the right
            
         }
         else //if the input is not "I" then it is "L %C"
         {
            huffTree.setData(new Character(line.charAt(2))); //sets the data of the node to the third char in the input string
            
         }
      }
      return huffTree; //returns the node
   }
   
   
   /*
       a method used for debugging. traces the tree
   */
   
   private static void printTree(BinaryNode<Character> tree)
   {
      if(tree.getData() == null)
      {
         
         if(tree.hasLeftChild())
         {
            System.out.print("left ");
            printTree(tree.getLeftChild());
            System.out.println("up");
         }
         if(tree.hasRightChild())
         {
            System.out.print("right ");
            printTree(tree.getRightChild());
            System.out.println("up");
         }
      }
      else
      {
         System.out.println(tree.getData());
      }
   }
   
   //the initial call to the setValues() recursive method. Used to create the ArrayLists that the table is made from
   private static void setValues(BinaryNode<Character> tree)
   {
      setValues(tree.getLeftChild(), new StringBuilder("0")); //call down the left branch,
      setValues(tree.getRightChild(), new StringBuilder("1")); //call down the right branch
   }
   
   
   //the recursive setValues() method. The count parameter is the current binary path down the tree
   private static void setValues(BinaryNode<Character> tree, StringBuilder count)
   {
      if(tree.isLeaf()) //if the tree is a leaf
      {
         
         leaves.add(tree.getData()); //adds the node's data to the list of characters
         values.add(count.toString()); //adds the node's path to the list of paths
               
         
      }
      else
      {
         setValues(tree.getLeftChild(), new StringBuilder(count.toString() + "0")); //recursive call down the left path
            
           
         setValues(tree.getRightChild(), new StringBuilder(count.toString() + "1"));  //recursive call down the right path
         
         
      }
   }
   
   
   //outputs the table visually 
   private static void outputTable()
   {
      System.out.println("Index | Letter | Encoding"); //heading for the table
      System.out.println("--------------------");      //line between heading and data
      for(int num = 0; num < leaves.size(); num++)     //loops through the leaves ArrayList through a standard for loop
      {
         System.out.printf("%-5d | %-6C | %-10s%n", num, leaves.get(num), values.get(num)); //uses the index to print the both the character and value
      }
      
      System.out.println();
   }
   
   
   //reads the user input message and encodes it
   private static void encode(char[] message)
   {
      for(char letter : message) //enhanced for loop to go through all letters in the message
      {
         for(int index = 0; index < leaves.size(); index++) //looping through the letters in the tree
         {
            if(leaves.get(index).equals(new Character(letter))) //checks against the tree
            {
               System.out.println(values.get(index)); //encodes the letter
            }
         }
      }
      
   }
   
   
   //decodes the message by following along the given path
   private static void decode(BinaryNode<Character> keyTree, String message)
   {
      BinaryNode<Character> moving = keyTree;  //creates a mobile node
      for(int point = 0; point < message.length(); point++) //for loop to read through encoded message 
      {
         if(moving.isLeaf()) //checks if the current node is a leaf
         {
            System.out.print(moving.getData()); //if it is, prints the letter
            moving = keyTree; //resets the mobile node to the root
         }
         if(message.charAt(point) == '0') //if the character at in the message is a 0
         {
            moving = moving.getLeftChild();  //the node path moves left one
         }
         else //if the character is not a 0, then it must be a 1
         {
            moving = moving.getRightChild(); //node path moves right one
         }
         
      }
      System.out.println(moving.getData()); //prints the data of the very last leaf
      
   }
   
   
   
}